# Правила написания кода
____

### Создание обьекта на 3 и более элементов
При создании обьектов, равно как и массивов, содержащих большое количество свойств(элементов), и тем самым образующих строки, длиной более 20 символов, необходимо выполнять ряд условий:

Открывающая скобка располагается на той же строке;
Каждое свойство оформляется на новой строке;
Пробел после двоеточия;
Закрывающая скобка располагается на новой строке.

Хорошо
```
var superman = {
  defaults: { clark: 'kent' },
  type: 'alien',
  hidden: true
};
```
Плохо
```
var superman = {defaults: { clark: 'kent' }, type: 'alien', hidden: true};
```

### Переменные
Для именования переменных используйте существительные на английском языке(не транслит!). Имя переменной должно быть осмысленным.
Имя может состоять из букв, цифр, символов $ и _, не должно начинаться с цифры.

Хорошо
```
var vegetables;
```
Плохо
```
var ovoschi;
```

### Именование функции
Имя функции должно быть глаголом на английском языке или начинаться с него.
Для имён, состоящих из нескольких слов, используйте camelCase.

Хорошо
```
function editName() {
  // тело функции
};
```
Плохо
```
function pravkaspiska() {
  // тело функции
};
```

### Горизонтальные отступы
Отступ при вложенности - 1 таб на каждый уровень вложенности.

Хорошо
```
if (age < 98) {
  for (var i = 0, iMax = items.length; i < iMax; ++i) {
    // тело цикла
  }
}
```
Плохо
```
if (age < 98) {
for (var i = 0, iMax = items.length; i < iMax; ++i) {
// тело цикла
}
}
```

### Вертикальные отступы
Между логическими блоками(циклами, функциями и т.д.) следует оставлять пустую строку. Это делает код более читабельным. Избегайте блоков кода более 9 строк подряд.

Хорошо
```
var i;
var iMax = items.length;

for (i = 0; i < iMax, ++i) {
  // тело цикла
}

function showName() {
  // тело функции
}
```
Плохо
```
var i;
var iMax = items.length;
for (i = 0; i < iMax, ++i) {
  // тело цикла
}
function showName() {
  // тело функции
}
```
### Написание массива/ объекта
При напиаании этих елементов старайтесь не писатьвсё в одну строчку

хорошо
```
far fruits = [
                apple,
                pineapple,
                pear,
                cherry,
                cucumber
             ]
let data = { houseNumber,
            streetName,
            streetDirection,
            city,
            state,
            zip,
            lat,
            lon,
            currentLat,
            currentLon 
            }            
```
Плохо
```
var fruts = [apple,pineapple,pear,cherry,cucumber];
let { houseNumber, streetName, streetDirection, city, state, zip, lat, lon, currentLat, currentLon }
```

### Пробелы
Используйте пробелы между параметрами и не используйте между именем функции и скобкой.

Хорошо
```
function edit(name, age) {
  // тело функции
}
```
Плохо
```
function edit (name,age) {
  // тело функции
}
```
#### При создании анонимной функции необходимо использовать пробел перед скобкой;

Хорошо
```
function (name, age) {
  // тело функции
}
```
Плохо
```
function(name,age) {
  // тело функции
}
```
#### Используйте пробелы вокруг операторов.

Хорошо
```
if (age < 100) {
  // тело цикла
}
```
Плохо
```
if (age<100) {
  // тело цикла
}
```

### Скобки
Открывающая фигурная скобка располагается на той же строке. Перед скобкой пробел. Закрывающая скобка располагается на новой строке.

Хорошо
```
function edit(name, age) {
  if (age < 100) {
    // тело цикла
  }
}
```
Плохо
```
function edit(name, age)
{
  if (age < 100) {/*тело цикла*/}
}
```

###  Кавычки
Для названия компонента используем одинарные скобки, а для стринга в коде двойные(ESLint вам подскажет)

Хорошо
```
import React from 'react';
var phrase = "random text";
```
Плохо
```
import React from "react";
var phrase = "random text";

или

import React from 'react';
var phrase = 'random text';
```

### Точка с запятой
В конце выражения обязательна точка с запятой.

Хорошо
```
var variable;
```
Плохо
```
var variable
```

### Комментарии
Однострочные комментарии начинаются с двойного слэша //. За ним обязательно должен идти пробел;

Многострочные комментарии располагаются между /* и */. За символом начала комментария обязательно должен идти пробел. Символ конца комментария располагается на новой строке.

Хорошо
```
/* Пример комментария.
Многострочного комментария.
*/

// Пример однострочного комментария.
```
Плохо
```
/*Пример комментария.
Многострочного комментария.*/

//Пример однострочного комментария.
```

### Перенос else
В цикле for else, else не переносится на новою строку 

Хорошо
```
  if (age < 100) {
    // тело цикла
  } else {
      // тело цикла
  }
```
Плохо
```
  if (age < 100) {
    // тело цикла
  } 
  else {
      // тело цикла
  }
```

### Arrow функции
Если функция просто возвращает переменую сокращаем функцию до одной строки

Хорошо
```
let myFunction = (a, b) => a * b;
```
Плохо
```
let myFunction =  function(a, b) {
    return a * b;
};
```

### Сокращение if
если есть возможность сокращаем if до такого выражения
```
требование ? если правда : если нет;
```

Хорошо
```
let a = 0;
let b = 1;
var money = a < b ? 100 : 0;
//Money = 100 так как это правда

или

let a = 0;
let b = 1;
var money = a > b ? 100 : 0;
//money = 0 так как это ложь
```
Плохо
```
let a = 0;
let b = 1;
if(a < b){
    var money = 100;
} else {
    var money = 0;
}
//money = 100 так как это правда
```

### Конкатинация строк
Делаем так
```
let a = 1;
let a = "яблоко";
$"У миши было {a} {b}";

// У миши было 1 яблоко
```

### Не создаем лишних переменных
Если переменая создана для того чтобы просто возвратить её

Хорошо
```
return new Data();

```
Плохо
```
let a = new Data();
return a;
```

### Уровни вложенности
Стараемся не делать слишком много уровней вложенности а выносить в отдельные функции

Хорошо
```
function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
  } else {
    return resault(x,n);
  }
}

function resault(x,n){
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
}
pow(2,2);
```
Плохо
```
function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
```

### Нагромождение кода
Выносим части кода в новый файл(компонент) и просто вызываем его на нужной странице так как React подразумивает работу с компонентами

Хорошо
```
<BrowserRouter>
    <Routes>
    <Route path="/login" exact element={<Login />} />
    <Route path="/signup" exact element={<SignUp />} />
    </Routes>
</BrowserRouter>
```
Плохо
```
Плохо писать всё в один файл а потом не мочь разобратся в нём
```

### Дестроктуризация переменных

Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.

Пример деструктуризации массива:
```
'use strict';

let [firstName, lastName] = ["Илья", "Кантор"];

alert(firstName); // Илья
alert(lastName);  // Кантор
```
При таком присвоении первое значение массива пойдёт в переменную firstName, второе – в lastName, а последующие (если есть) – будут отброшены.

Ненужные элементы массива также можно отбросить, поставив лишнюю запятую:
```
// первый и второй элементы не нужны
let [, , title] = "Юлий Цезарь Император Рима".split(" ");

alert(title); // Император
```
В коде выше первый и второй элементы массива никуда не записались, они были отброшены. Как, впрочем, и все элементы после третьего.

### Оператор «spread»
Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора "..." («spread», троеточие):
```
let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");

alert(firstName); // Юлий
alert(lastName);  // Цезарь
alert(rest);      // Император,Рима (массив из 2х элементов)
```

### Деструктуризация объекта
Деструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны «идти».
Объект справа – уже существующий, который мы хотим разбить на переменные. А слева – список переменных, в которые нужно соответствующие свойства записать.
```
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200
```
### Вложенные деструктуризации
Если объект или массив содержат другие объекты или массивы, и их тоже хочется разбить на переменные – не проблема.

Деструктуризации можно как угодно сочетать и вкладывать друг в друга.

В коде ниже options содержит подобъект и подмассив. В деструктуризации ниже сохраняется та же структура:
```
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Пончик", "Пирожное"]
}

let { title="Меню", size: {width, height}, items: [item1, item2] } = options;

// Меню 100 200 Пончик Пирожное
alert(title);  // Меню
alert(width);  // 100
alert(height); // 200
alert(item1);  // Пончик
alert(item2);  // Пирожное
```