Все команды Гит:
Создание коммита
- git add . : Добавляем все изменения перед коммитом(можна вместо "add ." вписать "add nazwa pliku" и тогда добавите только выбраные файлы
- git commit -m "Nazwa commitu": создаём новый коммит
Создание новых веток и переход между ними
- git branch NazwaBranchu : Создание новой ветки с именем NazwaBranchu
- git branch NazwaBranchu main^ : Создание новой ветки с именем NazwaBranchu на 1 коммит выше на ветке main
- git checkout NazwaBranchu : переходим с ветки main(или той на которой ты сейчас) на ветку NazwaBranchu
- git checkout -b NazwaBranchu : Создаём новую ветку и сразу же переходим на неё
Слияние веток
- git merge NazwaBranchu : Сливает выбраную ветку с текущей веткой
- git rebase NazwaBranchu : Создает копию текущего коммита в выбраную ветку(он не сливает ветки, а просто создает копию. Это значит что мы можем потом обращаться к тому коммиту или перейти на него с помощю id что бы продолжить)
- git NazwaBranchuKuda NazwaBranchuChto : Создает копию в выбраную ветку выбраноой ветки(то-есть создаёт копию в выбраной ветке выбраной ветки) 
Перемещение по древу Git [1]
- git checkout HashVietky : Установление HEAD на выбраный хешом коммит для просмотра или работы с ним(созданные коммиты будут в другой ветке)
- git checkout main^ : Перемещение на один коммит назад ^ в веке main(перемещяем только HEAD, при этом последний коммит в main мы не трогаем)
- git checkout main~2 : Перемещение на несколько коммитов назад ~<num>(в данном случае 2)(перемещяем только HEAD, при этом последний коммит в main мы не трогаем)
- git branch -f main HEAD~3 : Переместит (принудительно) ветку main на три родителя назад от HEAD.(После этого создание коммита создаст новую ветку)
- git branch -f main InnyBranch : Перемещает с последнего коммита ветку на выбранный коммит выбраной ветки(при этом коммиты с ветки main остаються и к ним можна обращатся и работать с ними)
Отмена изменений в Git [2]
- git reset BranchName : отменяет коммиты на локальной ветке(только у тебя на компютере) до выбраного коммита
- git revert BranchName создаёт дополнительный коммит отменяя изменения выбраного коммита(можно использовать удалёно)
Перемещение изменений [3]
- git cherry-pick C2 C4 : Копируем выбраные коммиты в текущую ветку(C3,C4 это для примера хеш выбраного комитта). Можно давать много елементов до копирования, не только два
- git rebase -i HEAD~4 : Возможность переставления 4 коммитов в верх начиная с HEAD(я хз как этим пользоватся в реальной консоле, так что врятли будем пользоваться этим)
Изменение предыдущих коммитов [4]
- git commit --amend -m"" : Изменяет текущий коммит 

/////////////////////////////////////////////////////////////////////////////////////////
[1]
Перемещение по древу Git
В первую очередь, поговорим о "HEAD". HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.
Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.
Detaching HEAD
Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту.Чтобы вернуть HEAD на место используйте "git checkout NuznyjCommit"
HEAD нужен для того что бы на пример переходить к предыдущим коммитам что-бы посмотреть их(мало ли у тебя на текущем коммите баг и ты решил посмотреть где он появился).К предыдущим коммитам перезодим с помощю хешов данных коммитов(можем написать первые пару знаков хеша для этого)
Пример
- git checkout HashVietky : Установление HEAD на выбраный хешом коммит для просмотра или работы с ним(созданные коммиты будут в другой ветке)
- git checkout main^ : Перемещение на один коммит назад ^ в веке main(перемещяем только HEAD, при этом последний коммит в main мы не трогаем)
- git checkout main~2 : Перемещение на несколько коммитов назад ~<num>(в данном случае 2)(перемещяем только HEAD, при этом последний коммит в main мы не трогаем)
- git branch -f main HEAD~3 : Переместит (принудительно) ветку main на три родителя назад от HEAD.(После этого создание коммита создаст новую ветку)
- git branch -f main InnyBranch : Перемещает с последнего коммита ветку на выбранный коммит выбраной ветки(при этом коммиты с ветки main остаються и к ним можна обращатся и работать с ними)

Отмена изменений в Git [2]
Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются).
Сейчас сфокусируемся на высокоуровневой части.
Есть два основных способа отмены изменений в Git: первый - это git reset, а второй - git revert.
1. Git Reset:
git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.
- git reset BranchName : отменяет коммиты на локальной ветке(только у тебя на компютере) до выбраного коммита
2. Git Revert
Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.
Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert.После revert можно сделать push и поделиться изменениями с остальными.
- git revert BranchName создаёт дополнительный коммит отменяя изменения выбраного коммита(можно использовать удалёно(то есть первый способ только для тебя, а второй для пуша на гитхаб))

Перемещение изменений [3]
Итак, мы уже освоили основы Git: коммиты, ветки, перемещение по дереву изменений. Уже этих знаний достаточно, чтобы овладеть 90% мощью Git-репозиториев и покрыть нужды разработчиков.
А оставшиеся 10% будут очень полезны при сложных workflow (или если ты попал в сложную ситуацию). Теперь речь пойдёт о перемещении изменений — возможности,
 позволяющей разработчику сказать "Хочу, чтобы эти изменения были вот тут, а вот эти — вон там" и получить точные, правильные результаты, не теряя при этом гибкости разработки.
1. Git Cherry-pick
Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD).Сherry-pick поместит любой коммит сразу после HEAD (только если этот коммит не является предком HEAD)
- git cherry-pick C2 C4 : Копируем выбраные коммиты в текущую ветку(C3,C4 это для примера хеш выбраного комитта). Можно давать много елементов до копирования, не только два
2. Git Interactive Rebase
Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)
Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.
- git rebase -i HEAD~4 : Возможность переставления 4 коммитов в верх начиная с HEAD(я хз как этим пользоватся в реальной консоле, так что врятли будем пользоваться этим)

Изменение предыдущих коммитов [4]
- git commit --amend -m"" : Изменяет текущий коммит 
Что бы изменить коммит который выше текущего, то используем такую схему:
	-git rebase -i HEAD~2 : Выбираем нужный коммит и ставим в нужную последовательность(в данном случае переворачиваем меняя местами).
	-git commit --amend -m "" : Изменяем нужный текущий коммит
	-git rebase -i HEAD~2 : Возвращаем коммиты в предыдущеё состояние(Переставляем обратно). 
Можно исользовать cherry-pick вместо rebase -i
	-git cherry-pick С2 С3: Выбираем нужный коммит и ставим в нужную последовательность(в данном случае переворачиваем меняя местами).
	-git commit --amend -m "" : Изменяем нужный текущий коммит
	-git cherry-pick С3 С2: Возвращаем коммиты в предыдущеё состояние(Переставляем обратно). 
Теги
HEAD это тег который Git ставит на коммит по умолчанию
- git tag v1 C1 : Надание тега для коммита что бы обращаться к нему не по хешу а по тегу( в данном случае v1 это название тега, а C1 хеш коммита)

Пасхалка:

Я надеюсь что вы это прочитали иначе а зачем  это тода делаю ??
Если прочитали это сообщение то можете написать в чат "Лах бусинка"
